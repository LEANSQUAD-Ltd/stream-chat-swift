(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{125:function(e,n,t){"use strict";t.d(n,"a",(function(){return g})),t.d(n,"b",(function(){return b}));var a=t(0),s=t.n(a);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,s=function(e,n){if(null==e)return{};var t,a,s={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var c=s.a.createContext({}),d=function(e){var n=s.a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},g=function(e){var n=d(e.components);return s.a.createElement(c.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return s.a.createElement(s.a.Fragment,{},n)}},m=s.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),g=d(t),m=a,b=g["".concat(l,".").concat(m)]||g[m]||p[m]||i;return t?s.a.createElement(b,r(r({ref:n},c),{},{components:t})):s.a.createElement(b,r({ref:n},c))}));function b(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,l=new Array(i);l[0]=m;var r={};for(var o in n)hasOwnProperty.call(n,o)&&(r[o]=n[o]);r.originalType=e,r.mdxType="string"==typeof e?e:a,l[1]=r;for(var c=2;c<i;c++)l[c]=t[c];return s.a.createElement.apply(null,l)}return s.a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},91:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return l})),t.d(n,"metadata",(function(){return r})),t.d(n,"toc",(function(){return o})),t.d(n,"default",(function(){return d}));var a=t(3),s=t(7),i=(t(0),t(125)),l={title:"Working with Messages"},r={unversionedId:"guides/working-with-messages",id:"guides/working-with-messages",isDocsHomePage:!1,title:"Working with Messages",description:"Message object",source:"@site/docs/guides/working-with-messages.md",slug:"/guides/working-with-messages",permalink:"/stream-chat-swift/guides/working-with-messages",editUrl:"https://github.com/GetStream/stream-chat-swift/edit/main/stream-chat-swift-docs/docs/guides/working-with-messages.md",version:"current",sidebar:"docs",previous:{title:"Working with a Channel",permalink:"/stream-chat-swift/guides/working-with-a-channel"},next:{title:"Working with User",permalink:"/stream-chat-swift/guides/working-with-user"}},o=[{value:"Message object",id:"message-object",children:[]},{value:"Optimistic updates",id:"optimistic-updates",children:[]},{value:"Get a Message by its ID",id:"get-a-message-by-its-id",children:[]},{value:"Create a message",id:"create-a-message",children:[]},{value:"How sending a message works",id:"how-sending-a-message-works",children:[]},{value:"Edit a message",id:"edit-a-message",children:[]},{value:"Delete a message",id:"delete-a-message",children:[]},{value:"Reply a message",id:"reply-a-message",children:[]}],c={toc:o};function d(e){var n=e.components,t=Object(s.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},c,t,{components:n,mdxType:"MDXLayout"}),Object(i.b)("h2",{id:"message-object"},"Message object"),Object(i.b)("p",null,"A message is represented by ",Object(i.b)("inlineCode",{parentName:"p"},"ChatMessage")," model.\nDepending on combination of its properties messages appear differently, a screenshot on the left showcases the most common types of messages. A screenshot on the right shows how some of ",Object(i.b)("inlineCode",{parentName:"p"},"ChatMessage")," properties are reflected in views:"),Object(i.b)("img",{src:"../img/messages-showcase.png",width:"40%"}),Object(i.b)("img",{src:"../img/messages-properties.png",width:"40%"}),Object(i.b)("h2",{id:"optimistic-updates"},"Optimistic updates"),Object(i.b)("p",null,"Optimistic updates model is applied to messages, meaning that when there is a change to local messages state it is propagated to chat components so it is displayed for users right away and then it's synchronized with backend. In case of synchronization failure users may be prompted to retry the failed action."),Object(i.b)("img",{src:"../img/message-failure-resend.png",width:"30%"}),Object(i.b)("p",null,"This makes ",Object(i.b)("inlineCode",{parentName:"p"},"LocalMessageState")," one of the most important properties in message's lifecycle, because it's used for keeping messages in sync with backend."),Object(i.b)("h2",{id:"get-a-message-by-its-id"},"Get a Message by its ID"),Object(i.b)("p",null,"You can get a single message by its ID:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-swift"},'import StreamChat \n\n/// Use the `ChatClient` to create a\n/// `ChatMessageController` with the `ChannelId`. \nlet messageController = chatClient.messageController(\n   cid: ChannelId(type: .messaging, id: "general"),\n   messageId: "message-id" \n) \n\n/// Get the message \nmessageController.synchronize { error in \n   // handle possible errors / access message \n   print(error ?? messageController.message!) \n} \n')),Object(i.b)("h2",{id:"create-a-message"},"Create a message"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"ComposerVC")," is a UI component that handles messages creation:"),Object(i.b)("img",{src:"../img/composer-ui.png",width:"50%"}),Object(i.b)("p",null,"If you are using your own component for a message composer you can use ",Object(i.b)("inlineCode",{parentName:"p"},"ChatChannelController")," to create messages:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-swift"},'let controller = ChatChannelController(\n    channelQuery: ChannelQuery(cid: ChannelId(type: .messaging, id: "general")),\n    client: client\n)\ncontroller.createNewMessage(\n    text: "Hello World!",\n    pinning: .noExpiration,\n    attachments: [image],\n    quotedMessageId: quotedMessage.id,\n    completion: { result in\n        switch result {\n        case .success(let messageId):\n            print(messageId)\n        case .failure(let error):\n            print(error)\n        }\n    }\n)\n')),Object(i.b)("p",null,"More info on ",Object(i.b)("a",{parentName:"p",href:"/stream-chat-swift/guides/pinned-messages"},"Pinning")," and ",Object(i.b)("a",{parentName:"p",href:"/stream-chat-swift/guides/working-with-attachments"},"Attachments")," can be found in corresponding guides."),Object(i.b)("p",null,"More on ",Object(i.b)("a",{parentName:"p",href:"#replying-a-message"},"Quoted"),"  messages could be found in this guide below."),Object(i.b)("h2",{id:"how-sending-a-message-works"},"How sending a message works"),Object(i.b)("p",null,"When ",Object(i.b)("inlineCode",{parentName:"p"},"createNewMessage")," is called, ",Object(i.b)("inlineCode",{parentName:"p"},"ChatChannelController")," creates a new message locally and schedules it for send."),Object(i.b)("p",null,"Uploading is handled by an internal entity called ",Object(i.b)("inlineCode",{parentName:"p"},"MessageSender"),". It automatically starts\nuploading when it detects locally cached messages with ",Object(i.b)("inlineCode",{parentName:"p"},".pendingSend")," state. "),Object(i.b)("p",null,"There is no need to take care of ",Object(i.b)("inlineCode",{parentName:"p"},"MessageSender"),", it is created and added to the list of background workers by ",Object(i.b)("inlineCode",{parentName:"p"},"ChatClient"),"."),Object(i.b)("p",null,"Sending of the message has the following phases:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"When a message with ",Object(i.b)("inlineCode",{parentName:"li"},".pendingSend")," state local state appears in the db, the sender queues it in the sending queue for the channel the message belongs to."),Object(i.b)("li",{parentName:"ol"},"The pending messages are send one by one order by their ",Object(i.b)("inlineCode",{parentName:"li"},"locallyCreatedAt")," value ascending."),Object(i.b)("li",{parentName:"ol"},"When the message is being sent, its local state is changed to ",Object(i.b)("inlineCode",{parentName:"li"},".sending")),Object(i.b)("li",{parentName:"ol"},"If the operation is successful, the local state of the message is changed to ",Object(i.b)("inlineCode",{parentName:"li"},"nil"),". If the operation fails, the local state of is changed to ",Object(i.b)("inlineCode",{parentName:"li"},"sendingFailed"),".")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"                                    \u250c\u2500\u2500\u25b6  `nil` if success \n  `pendingSend` \u2500\u2500\u2500\u2500\u2500\u2500\u25b6 `sending` \u2500\u2500\u2524                      \n                                    \u2514\u2500\u25b6   `sendingFailed`                                                         \n")),Object(i.b)("p",null,"This behavior makes it possible to update your UI with the new message immediately without blocking the UI:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-swift"},"class MyChannelViewController: UIViewController {\n    let controller = ChannelController(cid: <#ChannelId#>)\n\n    func sendMessage(text: String) {\n        // This method creates a new message locally,\n        // initially with `localState == .pendingSend`\n        controller.createNewMessage(text: text)\n    }\n\n    // Example handling for Message local state:\n    func tableView(\n        _ tableView: UITableView,\n         cellForRowAt indexPath: IndexPath\n    ) -> UITableViewCell { \n        ...\n        let message = controller.messages[indexPath.row]\n        if message.localState == .pendingSend {\n            // show message as pending send\n\n        } else if message.localState == .sendingFailed {\n            // show retry button for the message\n        }\n        ...\n    }\n}\n")),Object(i.b)("div",{className:"admonition admonition-info alert alert--info"},Object(i.b)("div",{parentName:"div",className:"admonition-heading"},Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",{parentName:"h5",className:"admonition-icon"},Object(i.b)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},Object(i.b)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),Object(i.b)("div",{parentName:"div",className:"admonition-content"},Object(i.b)("p",{parentName:"div"},"When a message is created ",Object(i.b)("inlineCode",{parentName:"p"},"ChannelController")," sends ",Object(i.b)("em",{parentName:"p"},"stop typing event")," for this channel"))),Object(i.b)("h2",{id:"edit-a-message"},"Edit a message"),Object(i.b)("p",null,"There is an action for editing messages:"),Object(i.b)("img",{src:"../img/messages-actions.png",width:"25%"}),Object(i.b)("p",null,"When a user is editing a message ",Object(i.b)("inlineCode",{parentName:"p"},"ComposerVC")," takes the following appearance:"),Object(i.b)("img",{src:"../img/composer-edit.png",width:"50%"}),Object(i.b)("p",null,"If you use your own implementation for composer view, the same could be done with ",Object(i.b)("inlineCode",{parentName:"p"},"ChatMessageController"),":"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-swift"},'let messageController = chatClient.messageController(\n    cid: channelId,\n    messageId: messageId\n) \nmessageController.editMessage(text: "World Hello!") { error in\n    if let error = error {\n        print(error)\n    }\n}\n')),Object(i.b)("p",null,"Editing a message has several phases:"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"MessageModel.localState")," states when editing a message:")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"                                    \u250c\u2500\u2500\u25b6  `nil` if success \n  `pendingSync` \u2500\u2500\u2500\u2500\u2500\u2500\u25b6 `syncing` \u2500\u2500\u2524                      \n                                    \u2514\u2500\u25b6   `syncingFailed`                                                         \n")),Object(i.b)("p",null,"This behavior makes it possible to update your UI with the updated message immediately without blocking the UI:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-swift"},"class MyChannelViewController: UIViewController {\n    let controller = ChannelController(cid: <#ChannelId#>)\n\n    func editMessage(message: ChatMessage, text: String) {\n        let messageController = controller.client.messageController(\n            cid: <#ChannelId#>,\n            messageId: message.id\n        )\n\n        // This method updates a message locally\n        // with the `localState == .pendingSync`\n        messageController.editMessage(text: text)\n    }\n\n    // Example handling for Message local state:\n    func tableView(\n        _ tableView: UITableView,\n        cellForRowAt indexPath: IndexPath\n    ) -> UITableViewCell { \n        ...\n        let message = controller.messages[indexPath.row]\n        if message.localState == .pendingSync {\n            // show message as not being synced with the servers\n\n        } else if message.localState == .syncingFailed {\n            // show retry button\n        }\n        ...\n    }\n}\n")),Object(i.b)("h2",{id:"delete-a-message"},"Delete a message"),Object(i.b)("p",null,"A message can be deleted with the corresponding action:"),Object(i.b)("img",{src:"../img/messages-actions.png",width:"25%"}),Object(i.b)("p",null,"When a user deletes a message it will be hidden for all the rest users in conversation, but it will appear for the user who deleted it like this:"),Object(i.b)("img",{src:"../img/message-delete.png",width:"50%"}),Object(i.b)("p",null,"In an upcoming version it will become customizable, so it will be possible to hide deleted messages for all participants in a conversation."),Object(i.b)("p",null,"Message deletion is handled by ",Object(i.b)("inlineCode",{parentName:"p"},"ChatMessageController"),":"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-swift"},"let messageController = chatClient.messageController(\n    cid: channelId,\n    messageId: messageId\n) \nmessageController.deleteMessage { error in\n    if let error = error {\n        print(error)\n    }\n}\n")),Object(i.b)("p",null,"If the message has ",Object(i.b)("inlineCode",{parentName:"p"},".pendingSend")," or ",Object(i.b)("inlineCode",{parentName:"p"},".sendingFailed")," state it will be removed locally as it hasn't been sent yet."),Object(i.b)("p",null,"If the message has some other local state it should be removed on the backend.\nBefore the ",Object(i.b)("inlineCode",{parentName:"p"},"delete")," network call happens the local state is set to ",Object(i.b)("inlineCode",{parentName:"p"},"deleting")," and based on\nthe response it becomes either ",Object(i.b)("inlineCode",{parentName:"p"},"nil")," if request succeeds or ",Object(i.b)("inlineCode",{parentName:"p"},"deletingFailed")," if request fails."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"                \u250c\u2500\u2500\u25b6  `nil` if success \n   `deleting` \u2500\u2500\u2524                      \n                \u2514\u2500\u25b6  `deletingFailed`                                \n")),Object(i.b)("p",null,"This behavior makes it possible to update your UI with the updated message immediately without blocking the UI:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-swift"},"class MyChannelViewController: UIViewController {\n    let controller = ChannelController(cid: <#ChannelId#>)\n\n    func deleteMessage(message: Message) {\n        // Create a `MessageController` for the message you want to delete\n        let messageController = controller.client.messageController(\n            cid: channelController.channelQuery.cid,\n            messageId: message.id\n        )\n\n        // Delete the message\n        messageController.deleteMessage()\n    }\n\n    // Example handling for Message local state:\n    func tableView(\n        _ tableView: UITableView,\n        cellForRowAt indexPath: IndexPath\n    ) -> UITableViewCell { \n        ...\n        let message = controller.messages[indexPath.row]\n        if message.localState == .deleting {\n            // show message as being deleted\n\n        } else if message.localState == .deletingFailed {\n            // show retry button for deleting the message\n        }\n        ...\n    }\n}\n")),Object(i.b)("h2",{id:"reply-a-message"},"Reply a message"),Object(i.b)("p",null,"There are two ways of replying a message:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Quoted reply"),"."),Object(i.b)("p",{parentName:"li"},"In case if ",Object(i.b)("inlineCode",{parentName:"p"},"ComposerVC")," is used it looks like this during composing, and the resulting message will show both quoted message and the reply itself."),Object(i.b)("img",{src:"../img/composer-quoted.png",width:"50%"})),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Thread reply")),Object(i.b)("p",{parentName:"li"},"  Initiating a thread reply takes a user into thread details screen and the resulting message will look like a normal message that is placed inside the thread. It is also possible to duplicate it to the parent channel."),Object(i.b)("img",{src:"../img/thread-details.png",width:"35%"}),Object(i.b)("p",{parentName:"li"},"  A message with thread replies appears like this:"),Object(i.b)("img",{src:"../img/thread-reply.png",width:"35%"}))),Object(i.b)("p",null,"If you use your own implementation for message composer you can create a ",Object(i.b)("strong",{parentName:"p"},"thread reply")," for a message with ",Object(i.b)("inlineCode",{parentName:"p"},"MessageController"),":"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-swift"},'let messageController = chatClient.messageController(\n    cid: channelId,\n    messageId: "message-id"\n)\nmessageController.createNewReply(\n    text: "Thread reply",\n    pinning: nil,\n    attachments: [],\n    showReplyInChannel: true,\n    quotedMessageId: nil\n)\n')),Object(i.b)("p",null,"A ",Object(i.b)("strong",{parentName:"p"},"quoted reply")," can be created like this:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-swift"},'let controller = ChatChannelController(\n    channelQuery: ChannelQuery(cid: ChannelId(type: .messaging, id: "general")),\n    client: client\n)\nchannelController.createNewMessage(\n    text: "Quoted reply",\n    pinning: nil,\n    attachments: [],\n    quotedMessageId: "quoted-message-id"\n)\n')))}d.isMDXComponent=!0}}]);